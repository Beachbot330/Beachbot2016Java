// RobotBuilder Version: 2.0BB
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc330.subsystems;

import org.usfirst.frc330.Robot;
import org.usfirst.frc330.RobotMap;
import org.usfirst.frc330.commands.*;
import org.usfirst.frc330.constants.ArmConst;
import org.usfirst.frc330.constants.TurretConst;
import org.usfirst.frc330.util.CSVLoggable;

import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;



import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Arm extends Subsystem {

	//TODO delete armPID and convert all methods to use CAN Talon armL
	protected PIDController armPID;
	double    tempSetPoint;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon armL = RobotMap.armarmL;
    private final CANTalon armR = RobotMap.armarmR;
    private final Solenoid portcullisWedge = RobotMap.armPortcullisWedge;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    // Arm PIDController source and output objects
    public PIDOutput armPIDOutput = new PIDOutput() {

		@Override
		public void pidWrite(double output) {
			// TODO Auto-generated method stub
		    setArm(output);
		}
    	
    };
    
    public PIDSource armPIDSource = new PIDSource() {
		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			return getArmAngle();
		}

		@Override
		public void setPIDSourceType(PIDSourceType arg0) {			
		}
    	
    };
    
	/////////////////////////////////////////////////////////////
	// MAIN CLASS
	/////////////////////////////////////////////////////////////
    public Arm() {

    	super();
    	
    	// Arm PIDController object
    	armPID = new PIDController(
    			ArmConst.proportional, 
    			ArmConst.integral, 
    			ArmConst.derivative, 
    			armPIDSource, 
    			armPIDOutput,
    			0.01);
    	armPID.setAbsoluteTolerance(ArmConst.tolerance);
    	
    	// Add to Smart Dashboard
    	SmartDashboard.putData("ArmPID", armPID);
    	
    	//set armR to follow armL, reversed
    	armR.changeControlMode(TalonControlMode.Follower);
    	armR.set(armL.getDeviceID());
    	armR.reverseOutput(true);
    	
		/////////////////////////////////////////////////////////////////
		// LOG IT!
    	// TODO: Add additional logging as needed
		
		CSVLoggable temp = new CSVLoggable(true) {
			public double get() { return getArmAngle(); }
		};
		
		Robot.csvLogger.add("ArmAngle", temp);

    }
    
	/////////////////////////////////////////////////////////////
	// GET methods
	/////////////////////////////////////////////////////////////
    
    // Get input from encoder for Arm
    public double getArmAngle()
	{
    	double fetchEncoder = armL.getPosition();
    	double count2deg    = 0.0;
    	 	
    	// NOTES: 
    	// 4096 counts per revolution
    	// 5 revolution of encoder to revolution of arm
    	// TLDR; This means 0-72 degrees = 0-4096 counts
    	
    	count2deg = (ArmConst.maxAngleDegrees * fetchEncoder) / ArmConst.maxEncoderCounts;
    	
		return count2deg;
	}

	public double getArmOutput() {
		return armL.get();
	}
    
	public double pidGet() {
		return getArmAngle();
	}
	
	/////////////////////////////////////////////////////////////
	// SET methods
	/////////////////////////////////////////////////////////////
	/* Set the arm */
    public void setArm(double output) {
    	
    	// Is the turret centered?
    	boolean centered = Robot.turret.getTurretAngle() < TurretConst.turretSafeLimitCW &&
    					   Robot.turret.getTurretAngle() > TurretConst.turretSafeLimitCCW;
    					   
    	//Don't let the arm go down if the turret is not centered
    	if ( !centered && output < 0) {
    		armL.set(0);
    	}
    	/* AHHHH! The arm would eat the ground */
    	else if ( getArmAngle() < ArmConst.limitLowerAngle && output < 0) {
    		armL.set(0);
    	/* OH NOES! The arm would flip off the back of the robot */
    	} else if ( getArmAngle() > ArmConst.limitUpperAngle && output > 0) {
    		armL.set(0);
    	/* We good */
    	} else {
    		armL.set(output);
    	}
    }
    
    /* Set the arm angle */
    public void setArmAngle(double position) {
    	armPID.setSetpoint(position);
    }
	
    public void setTurretAbsoluteTolerance(double absvalue) {
		armPID.setAbsoluteTolerance(absvalue);
	}
    
    public void setPIDConstants (double P, double I, double D, double F)
	{
		armPID.setPID(P, I, D, F);
	}
    
    // Quadrants are zero-indexed (0-4)
    // 0 = Lowest; 4 = Highest
    public void setQuadrantPosition(int quadrant)
    {
    	// Grab positioning from arm angle
    	double positionRawCount = armL.getPosition();
    	int    tempCtn          = 0;
    	
    	if ( quadrant >= ArmConst.minQuadrant && quadrant <= ArmConst.maxQuadrant )
    	{
    		// Set the position
    		tempCtn = ArmConst.maxEncoderCounts * quadrant;
    		armL.setPosition(positionRawCount + tempCtn);
    	}
    	else
    	{
    		throw new RuntimeException("setQuadrantPosition: Quadrant must be integer value 0-4.");
    	}  	
    	
    }
    
	/////////////////////////////////////////////////////////////
	// OTHER Methods (helper functions and commands)
	/////////////////////////////////////////////////////////////
    /* Control the arm manually */
    public void manualArm() {

    	double armCommand = Robot.oi.armJoystick.getY();	

    	if ( Math.abs(armCommand) > ArmConst.deadZone) {
			if (armPID.isEnabled())
				armPID.disable();
		} else if ( !armPID.isEnabled() ) {
    		tempSetPoint = this.getArmAngle();
    		
    		if ( tempSetPoint < ArmConst.limitLowerAngle ) {
    			tempSetPoint = ArmConst.limitLowerAngle;
    		} else if ( tempSetPoint > ArmConst.limitUpperAngle ) {
    			tempSetPoint = ArmConst.limitUpperAngle;
    		}
    	
    		armPID.setSetpoint(tempSetPoint);
    		armPID.enable();
    	}
    	
    }

    public void stopArm()
	{
		if (armPID.isEnabled())
		{
			armPID.reset();
		}
	}
    
    public synchronized boolean isEnable() {
		return armPID.isEnabled();
	}
    
    public void setArmAbsoluteTolerance(double absvalue) {
		armPID.setAbsoluteTolerance(absvalue);
	}
    
    // Method to Enable Arm
    public synchronized void enableArm() {
        armPID.enable();
    }
    
    // Method to check if Arm is on target
    public synchronized boolean onArmTarget() {
        return armPID.onTarget();
    }
    
    public void retractStinger() {
    	portcullisWedge.set(false);
    }
    public void deployStinger() {
    	portcullisWedge.set(true);
    }
}
