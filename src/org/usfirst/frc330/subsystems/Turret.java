// RobotBuilder Version: 2.0BB
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc330.subsystems;

import org.usfirst.frc330.Robot;
import org.usfirst.frc330.RobotMap;
import org.usfirst.frc330.commands.*;
import org.usfirst.frc330.constants.ArmPos;
import org.usfirst.frc330.constants.TurretPos;
import org.usfirst.frc330.constants.TurretPos;
import org.usfirst.frc330.util.CSVLoggable;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Turret extends Subsystem {

	protected PIDController turretPID;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController turret = RobotMap.turretturret;
    private final Encoder turretEncoder = RobotMap.turretturretEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	// Turret PIDController source and output objects
	public PIDOutput turretPIDOutput = new PIDOutput()  {
		public void pidWrite(double output) {
			setTurret(output);
		}
	};

	public PIDSource turretPIDSource = new PIDSource() {
		public double pidGet() {
			return getTurretAngle();
		}

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}
	};

	/////////////////////////////////////////////////////////////
	// MAIN CLASS
	/////////////////////////////////////////////////////////////
	public Turret() {
		super();

		// Turret PIDController object
		turretPID = new PIDController(TurretPos.proportional,
				TurretPos.integral,
				TurretPos.derivitive,turretPIDSource,turretPIDOutput, 0.01);
		turretPID.setAbsoluteTolerance(TurretPos.tolerance);

		// Add to Smart Dashboard
		SmartDashboard.putData("TurretPID", turretPID);

		/////////////////////////////////////////////////////////////////
		// LOG IT!

		CSVLoggable temp = new CSVLoggable(true) {
			public double get() { return getTurretAngle(); }
		};
		Robot.csvLogger.add("TurretAngle", temp);
		
		//TODO: Add additional logging as needed

	}
	/////////////////////////////////////////////////////////////
	// SET methods
	/////////////////////////////////////////////////////////////

	public void setTurret(double output){
		double limitCW, limitCCW;
		
		//Reduced CW limit if arm is low
		if (Robot.arm.getArmAngle() < ArmPos.armSafeLimit){ 
			limitCW = TurretPos.turretSafeLimitCW;
			limitCCW = TurretPos.turretSafeLimitCCW;
		}
		else{
			limitCW = TurretPos.limitAngleCW;
			limitCCW = TurretPos.limitAngleCCW;
		}
		
		
		//Don't rotate too far CW
		if (getTurretAngle() > limitCW && output > 0)
			turret.set(0.0);
		
		//Dont't rotate too far CCW
		else if (getTurretAngle() < limitCCW && output < 0)
			turret.set(0.0);
		
		//Check current limits	
/*		else if (output > 0 && Robot.powerDP.getArmLeftCurrent() < ArmPos.currentLowerLimit)
			arm.set(0);
		else if (output < 0 && Robot.powerDP.getArmLeftCurrent() > ArmPos.currentUpperLimit)
			arm.set(0);
		else if (output > 0 && Robot.powerDP.getArmRightCurrent() < ArmPos.currentLowerLimit)
			arm.set(0);
		else if (output < 0 && Robot.powerDP.getArmRightCurrent() > ArmPos.currentUpperLimit)
			arm.set(0);*/
		
		//Else Go!
		else
			turret.set(output);

	}


	public void setTurretAngle(double position)
	{
		turretPID.setSetpoint(position);
	}


	/////////////////////////////////////////////////////////////
	// GET methods
	/////////////////////////////////////////////////////////////	
	public double getTurretAngle()
	{
		return 0.0;//TODO: Write this method
	}

	public double getTurretOutput() {
		return turret.get();
	}

	/////////////////////////////////////////////////////////////
	// PID Stuff
	/////////////////////////////////////////////////////////////
	public void setTurretAbsoluteTolerance(double absvalue) {
		turretPID.setAbsoluteTolerance(absvalue);
	}

	public synchronized double getTurretSetpoint() {
		return turretPID.getSetpoint();
	}

	// Method to check if Turret is on target
	public synchronized boolean onTurretTarget() {
		return turretPID.onTarget();
	}

	// Method returns if Turret is enabled
	public synchronized boolean isTurretEnabled() {
		return turretPID.isEnabled();
	}


	// Method to Enable Turret
	public synchronized void enableTurret() {
		turretPID.enable();
	}


	// Method to Disable Turret
	public synchronized void disableTurret() {
		turretPID.disable();
	}

	public void stopTurret()
	{
		if (turretPID.isEnabled())
		{
			turretPID.reset();
		}
	}

	public void setPIDConstants (double P, double I, double D, double F)
	{
		turretPID.setPID(P, I, D, F);
	}

	//public void pidWrite(double output) {
	//set(output);		
	//}

	public double pidGet() {
		return getTurretAngle();
	}

	//////////////////////////
	// Other Methods
	//////////////////////////
	double tempSetpoint;
	public void manualTurret() {
		double turretCommand = Robot.oi.armJoystick.getZ();
		if (Math.abs(turretCommand) > 0.03)
		{
			if (turretPID.isEnabled())
				turretPID.disable();
		}
		else if (!turretPID.isEnabled())
		{
			tempSetpoint = this.getTurretAngle();
			if(tempSetpoint > TurretPos.limitAngleCW)
				tempSetpoint = TurretPos.limitAngleCW;
			else if(tempSetpoint < TurretPos.limitAngleCCW)
				tempSetpoint = TurretPos.limitAngleCCW;
			turretPID.setSetpoint(tempSetpoint);
			turretPID.enable();
		} 
	}

	public synchronized boolean isEnable() {
		return turretPID.isEnabled();
	}
}

